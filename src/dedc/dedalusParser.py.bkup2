#!/usr/bin/env python

'''
dedalusParser.py
   Define the functionality for parsing Dedalus files.
'''

import os, sys
from pyparsing import *

# ------------------------------------------------------ #
# import sibling packages HERE!!!
packagePath  = os.path.abspath( __file__ + "/../.." )
sys.path.append( packagePath )

#from utils import tools, parseCommandLineInput
# ------------------------------------------------------ #

#############
#  GLOBALS  #
#############
DEDALUSPARSER_DEBUG = True

##################
#  CLEAN RESULT  #
##################
# input pyparse object of the form ([...], {...})
# output only [...]
def cleanResult( result ) :
  newResult = []

  numParsedStrings = len(result)
  for i in range(0, numParsedStrings) :
    newResult.append( result[i] )

  return newResult

###########
#  PARSE  #
###########
# input a ded line
# output parsed line
def parse( dedLine ) :
  # basic grammar
  paren      = Word( "()", exact=1 )
  sym        = Word( alphanums + "_" )
  amp        = Literal( "@" )
  dquote     = Literal( '"' )
  squote     = Literal( "'" )
  empty      = Literal( "_" )
  semi       = Literal( ";" )
  op         = oneOf( "+ - * / < > <= >=" )
  open_lit   = Word( "<" )
  closed_lit = Word( ">" )

  # keywords 
  notin_kw   = CaselessKeyword( "notin" )
  min_kw     = CaselessKeyword( "min" )
  max_kw     = CaselessKeyword( "max" )
  avg_kw     = CaselessKeyword( "avg" )
  sum_kw     = CaselessKeyword( "sum" )
  count_kw   = CaselessKeyword( "count" )
  next_kw    = CaselessKeyword( "next" )
  async_kw   = CaselessKeyword( "async" )

  # time arguments
  num        = Word( nums )
  timeArg    = num | next_kw | async_kw

  # define attributes
  baseAtt    = sym | empty

  # aggregate attributes
  aggCore    = open_lit + FollowedBy(sym) + FollowedBy(closed_lit)
  aggFull    = (min_kw | max_kw | avg_kw | sum_kw | count_kw | next_kw | async_kw) + aggCore

  # formla attributes
  fmla     = sym + op + sym

  # fact attributes
  fatt0    = baseAtt                          #fact attribute version 0
  fatt1    = dquote + baseAtt + dquote        #fact attribute version 1
  fatt2    = squote + baseAtt + squote        #fact attribute version 2
  fatt     = fatt0 | fatt1 | fatt2
  # fact attribute lists
  fattList = fatt + ZeroOrMore( "," + fatt )

  # rule attributes
  ratt     = fmla #| aggFull | baseAtt    # rule attributes
  # rule attribute lists
  rattList = ratt + Optional(",")

  # comments in dedalus (do not touch!!!)
  comment  = Literal( "//" )
  commentLine  = ZeroOrMore( comment + alphanums + "_" ) | ZeroOrMore( comment + alphanums + "_" + alphanums )

  # ------------------------------------------------------------- #
  #                          FACT                                 #

  fact = Optional(notin_kw) + sym + paren + fattList + paren + Or( (amp + timeArg) | semi) + Optional(commentLine) #Optional(cStyleComment) 

  # ------------------------------------------------------------- #
  #                           GOAL                                #

  goal        = sym + paren + commaSeparatedList + paren + ZeroOrMore(amp + timeArg)
  eol         = Optional( semi + Optional(commentLine) )
  subgoal     = (Optional(notin_kw) + goal + eol) | (fmla + eol)
  subgoalList = subgoal + ZeroOrMore( Optional(",") + subgoal )
  ruleOp      = Literal( ":-" )
  rule        = goal + ruleOp + subgoalList

  # ------------------------------------------------------------- #

  # return tuples
  if ";" in dedLine :
    if ":-" in dedLine :
      if DEDALUSPARSER_DEBUG :
        print "dedLine = " + dedLine
      result = rule.parseString( dedLine )
      ret    = cleanResult( result )
      if DEDALUSPARSER_DEBUG :
        print "ret = " + str(ret)
      return ("rule", ret)
#      try :
#        result = rule.parseString( dedLine )
#        ret    = cleanResult( result )
#        return ("rule", ret)
#      except :
#        sys.exit( "\nERROR: Invalid syntax in rule line : " + dedLine + "Note rule attributes cannot have quotes.\n")
    else :
      try :
        result = fact.parseString( dedLine )
        ret    = cleanResult( result )
        return ("fact", ret)
      except :
        sys.exit( "\nERROR: Invalid syntax in fact line : " + dedLine + "Note fact attributes must be surrounded by quotes.\n" )
  else :
    return None

###################
#  PARSE DEDALUS  #
###################
# input name of raw dedalus file
# output array of arrays containing the contents of parsed ded lines

# WARNING: CANNOT write rules or facts on multiple lines.
def parseDedalus( dedFile ) :
  parsedLines = []

  # "always check if files exist" -- Ye Olde SE proverb
  if os.path.isfile( dedFile ) :
    f = open( dedFile, "r" )
    for line in f :
      if "/" == line[0] : # skip lines beginning with a comment
        continue
      result = parse( line )
      if not result == None :
        parsedLines.append( result )

  else :
    sys.exit( "ERROR: File at " + dedFile + " does not exist.\nAborting..." )

  return parsedLines

##########
#  MAIN  #
##########
if __name__ == "__main__" :
  #parse( "watch_state(F-1, H/1, S+1)@next :- watch_state(F/1, 5+H, 6*S) ; //asfhkjl asdf" )
  parse( "watch_state(F) :- watch_state(F) ;" )

#########
#  EOF  #
#########
